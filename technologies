{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "REST (от англ. Representational State Transfer — «передача репрезентативного состояния» или «передача „самоописываемого“ состояния») — архитектурный стиль взаимодействия компонентов распределённого приложения в сети. Другими словами, REST — это набор правил того, как программисту организовать написание кода серверного приложения, чтобы все системы легко обменивались данными и приложение можно было масштабировать. REST представляет собой согласованный набор ограничений, учитываемых при проектировании распределённой гипермедиа-системы. В определённых случаях (интернет-магазины, поисковые системы, прочие системы, основанные на данных) это приводит к повышению производительности и упрощению архитектуры. В широком смысле компоненты в REST взаимодействуют наподобие взаимодействия клиентов и серверов во Всемирной паутине.\n",
    "\n",
    "Существует шесть обязательных ограничений для построения распределённых REST-приложений по Филдингу:\n",
    "\n",
    "1. Единный интерфейс\n",
    "Единый интерфейс определяет интерфейс между клиентами и серверами. Это упрощает и отделяет архитектуру, которая позволяет каждой части развиваться самостоятельно. Четыре принципа единого интерфейса:\n",
    "    - Основан на ресурсах\n",
    "Отдельные ресурсы определяются в запросе, для чего используется URI, как идентификатор ресурсов. Сами ресурсы концептуально отделены от представлений, которые возвращаются клиенту. Например, сервер не отправляет свою базу данных, а, скорее, некоторые HTML, XML или JSON объекты, которые представляет некоторые записи из базы данных, но ни один из которых не является типом хранения внутри сервера.\n",
    "    - Манипуляции над ресурсами через представления\n",
    "Когда пользователь имеет представление о ресурсе, в том числе о связанных метаданных, он имеет достаточно информации для изменения или удаления ресурса на сервере, если у него есть на это разрешение\n",
    "    - Самодокументируемые сообщения\n",
    "Каждое сообщение содержит достаточно информации для описания того, как его выполнить. Например, вызываемый парсер может описываться с помощью Internet media type (так же известным как MIME) Ответы также явно указывают на их способность кешировать.\n",
    "    - Гипермедиа как средство изменения состояния приложения (HATEOAS)\n",
    "Клиенты изменяют состояние системы только через действия, которые динамически определены в гипермедиа на сервере (к примеру, гиперссылки в гипертексте). Исключая простые точки входа в приложение, клиент не может предположить, что доступна какая-то операция над каким-то ресурсом, если не получил информацию об этом в предыдущих запросах к серверу. Не существует универсального формата для предоставления ссылок между ресурсами, Web Linking (RFC 5988 -> RFC 8288) и JSON Hypermedia API Language Архивная копия от 27 июня 2014 на Wayback Machine являются двумя популярными форматами предоставления ссылок в REST HYPERMEDIA сервисах.\n",
    "\n",
    "2. Отсутсвие состояний\n",
    "Протокол взаимодействия между клиентом и сервером требует соблюдения следующего условия: в период между запросами клиента никакая информация о состоянии клиента на сервере не хранится. Все запросы от клиента должны быть составлены так, чтобы сервер получил всю необходимую информацию для выполнения запроса. Состояние сессии при этом сохраняется на стороне клиента. Информация о состоянии сессии может быть передана сервером какому-либо другому сервису (например, в службу базы данных) для поддержания устойчивого состояния, например, на период установления аутентификации. Клиент инициирует отправку запросов, когда возникает необходимость перейти в новое состояние.\n",
    "Во время обработки клиентских запросов считается, что клиент находится в переходном состоянии. Каждое отдельное состояние приложения представлено связями, которые могут быть задействованы при следующем обращении клиента. Отсутствие состояний клиента на сервере обеспечивает большую масштабируемость, так как сервер не должен поддерживать или общаться через состояние сеанса.\n",
    "\n",
    "3. Кэширование\n",
    "Как и во Всемирной паутине, клиенты, а также промежуточные узлы, могут выполнять кэширование ответов сервера. Ответы сервера, в свою очередь, должны иметь явное или неявное обозначение как кэшируемые или некэшируемые с целью предотвращения получения клиентами устаревших или неверных данных в ответ на последующие запросы. Правильное использование кэширования способно частично или полностью устранить некоторые клиент-серверные взаимодействия, ещё больше повышая производительность и масштабируемость системы.\n",
    "\n",
    "4. Клиент-сервер\n",
    "Единый интерфейс отделяет клиентов от серверов. Разделение интерфейсов означает, что, например, клиенты не связаны с хранением данных, которое остаётся внутри каждого сервера, так что мобильность кода клиента улучшается. Серверы не связаны с интерфейсом пользователя или состоянием, так что серверы могут быть проще и масштабируемы. Серверы и клиенты могут быть заменяемы и разрабатываться независимо, пока интерфейс не изменяется.\n",
    "\n",
    "5. Слои или многоуровневая система\n",
    "Обычно клиенты не могу сказать — они подключены напрямую к серверу или общаются через посредника. Промежуточный сервер может улучшить масштабируемость системы, обеспечивая балансировку нагрузки и предоставляя общий кэш. Слои также могут отвечать за политику безопасности.\n",
    "\n",
    "6. Код по требованию\n",
    "REST может позволить расширить функциональность клиента за счёт загрузки кода с сервера в виде апплетов или скриптов. Филдинг утверждает, что дополнительное ограничение позволяет проектировать архитектуру, поддерживающую желаемую функциональность в общем случае, но, возможно, за исключением некоторых контекстов."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "SOLID\n",
    "\n",
    "S - Принцип единственной ответственности (single responsibility principle)\n",
    "Для каждого класса должно быть определено единственное назначение. Все ресурсы, необходимые для его осуществления, должны быть инкапсулированы в этот класс и подчинены только этой задаче.\n",
    "\n",
    "O - Принцип открытости/закрытости (open-closed principle)\n",
    "Программные сущности должны быть:\n",
    "открыты для расширения: означает, что поведение сущности может быть расширено путём создания новых типов сущностей.\n",
    "закрыты для изменения: в результате расширения поведения сущности, не должны вноситься изменения в код, который эту сущность использует.\n",
    "Новый функционал добавляется на за счет внесения изменений в старый код , а за счет добавения к текущему функционалу новых сущностей.\n",
    "\n",
    "L - Принцип подстановки Лисков (Liskov substitution principle)\n",
    "Объекты в программе должны быть заменяемы на объекты дочерних классов без нарушения логики программы.\n",
    "\n",
    "I - Принцип разделения интерфейса (interface segregation principle)\n",
    "«много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения». Класс не должен содержать методов которые он не использует.\n",
    "\n",
    "D - Принцип инверсии зависимостей (dependency inversion principle)\n",
    "«Зависимость на Абстракциях. Нет зависимости на что-то конкретное». Модули высокого уровня не должны зависеть от модулей более низкого уровня, между ними должна быть какая либо абстракция."
   ]
  }
 ],
 "metadata": {
  "language_info": {
   "name": "python"
  },
  "orig_nbformat": 4
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
